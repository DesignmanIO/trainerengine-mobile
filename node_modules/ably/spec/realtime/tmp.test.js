"use strict";

define(['ably', 'shared_helper', 'async'], function(Ably, helper, async) {
	var exports = {},
		_exports = {},
		displayError = helper.displayError,
		utils = helper.Utils,
		createPM = Ably.Realtime.ProtocolMessage.fromDeserialized,
		mixin = utils.mixin,
		closeAndFinish = helper.closeAndFinish,
		monitorConnection = helper.monitorConnection,
		testOnAllTransports = helper.testOnAllTransports;

	exports.setupTmp = function(test) {
		test.expect(1);
		helper.setupApp(function(err) {
			if(err) {
				test.ok(false, displayError(err));
			} else {
				test.ok(true, 'setup app');
			}
			test.done();
		});
	};

	_exports.init_fallbacks_once_connected_2 = function(test) {
		var goodHost = helper.AblyRest().options.realtimeHost;
		var realtime = helper.AblyRealtime({
			log: {level: 4},
			httpMaxRetryCount: 3,
			restHost: 'a',
			fallbackHosts: [goodHost, 'b', 'c']
		});
		realtime.connection.once('connected', function() {
			var hosts = Ably.Rest.Http._getHosts(realtime);
			/* restHost rather than realtimeHost as that's what connectionManager
			 * knows about; converted to realtimeHost by the websocketTransport */
			test.equal(hosts[0], goodHost, 'Check connected realtime host is the first option');
			closeAndFinish(test, realtime);
		})
	}

	_exports.init_callbacks_promises = function(test) {
		var realtime,
			keyStr = helper.getTestApp().keys[0].keyStr,
			getOptions = function() { return {key: keyStr, autoConnect: false}; };

		realtime = new Ably.Realtime(getOptions());
		test.ok(!realtime.options.promises, 'Check promises defaults to false');

		realtime = new Ably.Realtime.Promise(getOptions());
		console.log("### with promise constructor ", realtime.options)
		test.ok(realtime.options.promises, 'Check promises default to true with promise constructor');

		if(!isBrowser && typeof require == 'function') {
			realtime = new require('../../promises').Realtime(getOptions());
			test.ok(realtime.options.promises, 'Check promises default to true with promise require target');

			realtime = new require('../../callbacks').Realtime(getOptions());
			test.ok(!realtime.options.promises, 'Check promises default to false with callback require target');
		}
		test.done();
	};

	_exports.auth_token_expires = function(test) {
		test.expect(4);
		var clientRealtime,
			rest = helper.AblyRest();

		rest.auth.requestToken({ ttl: 5000 }, null, function(err, tokenDetails) {
			if(err) {
				test.ok(false, displayError(err));
				test.done();
				return;
			}
			clientRealtime = helper.AblyRealtime({ tokenDetails: tokenDetails, queryTime: true, transports: ['xhr_streaming'], log: {level: 4} });

			clientRealtime.connection.on('failed', function(){
				test.ok(false, 'Failed to connect before token expired');
				closeAndFinish(test, clientRealtime);
			});
			clientRealtime.connection.once('connected', function(){
				clientRealtime.connection.off('failed');
				test.ok(true, 'Verify connection connected');
				clientRealtime.connection.once('disconnected', function(stateChange){
					test.ok(true, 'Verify connection disconnected');
					test.equal(stateChange.reason.statusCode, 401, 'Verify correct disconnect statusCode');
					test.equal(stateChange.reason.code, 40142, 'Verify correct disconnect code');
					closeAndFinish(test, clientRealtime);
				});
			});
		});
	}

	exports.connectionDetails = function(test) {
		test.expect(5);
		var realtime = helper.AblyRealtime({log: {level: 4}}),
			connectionManager = realtime.connection.connectionManager;
		realtime.connection.once('connected', function() {
			connectionManager.once('connectiondetails', function(details) {
				test.equal(details.connectionStateTtl, 12345, 'Check connectionStateTtl in event');
				test.equal(connectionManager.connectionStateTtl, 12345, 'Check connectionStateTtl set in connectionManager');
				test.equal(details.clientId, 'foo', 'Check clientId in event');
				test.equal(realtime.auth.clientId, 'foo', 'Check clientId set in auth');
				test.equal(realtime.options.maxMessageSize, 98765, 'Check maxMessageSize set');
				closeAndFinish(test, realtime);
			});
			connectionManager.activeProtocol.getTransport().onProtocolMessage(createPM({
				action: 4,
				connectionId: 'a',
				connectionKey: 'ab',
				connectionSerial: -1,
				connectionDetails: {
					clientId: 'foo',
					maxMessageSize: 98765,
					connectionStateTtl: 12345
				}
			}));
		});
		monitorConnection(test, realtime);
	};

	for(var i=0; i<10; i++) {
		exports['test_' + i] = exports.connectionDetails
	}

	return module.exports = helper.withTimeout(exports);
});
